#include "jebuf.h"
#include <assert.h>

#include <stdint.h>

/* jebuf: request an allocation size and get the actual size
 *        jemalloc will reserve. */

static size_t jebufSizeAllocation16(const size_t currentBufSize);
static size_t jebufSizeAllocation32(const size_t currentBufSize);
static size_t jebufSizeAllocation64(const size_t currentBufSize);

/* Convenience macros for byte calculations */
#define KiB *(size_t)1024
#define MiB *(size_t)1024 * 1024

/* Main size class generation function.
 * Returns memory size jemalloc will reserve if you request
 * an allocation of 'currentBufSize' bytes. */
size_t jebufSizeAllocation(const size_t currentBufSize) {
    if (currentBufSize <= 54 KiB) {
        return jebufSizeAllocation16(currentBufSize);
    }

    /* also limit 32 bit builds to 32 bit memory requets */
    if (currentBufSize <= 3584 MiB || sizeof(void *) == 4) {
        return jebufSizeAllocation32(currentBufSize);
    }

    return jebufSizeAllocation64(currentBufSize);
}

bool jebufUseNewAllocation(const size_t originalSize, const size_t newSize) {
    return jebufSizeAllocation(newSize) < jebufSizeAllocation(originalSize);
}

#define COUNT(array) (sizeof(array) / sizeof(*array))
#define JEEND (jebuf + COUNT(jebuf) - 1)

#define BINARY_SEARCH_BRANCH_FREE                                              \
    do {                                                                       \
        /* binary search for the nearest match */                              \
        do {                                                                   \
            mid = &result[half];                                               \
            result = (*mid < currentBufSize) ? mid : result;                   \
            n -= half;                                                         \
            half = n / 2;                                                      \
        } while (half > 0);                                                    \
    } while (0)

#define RETURN_MOSTLY_SAFE_RESULT                                              \
    do {                                                                       \
        if (*result < currentBufSize) {                                        \
            /* found lower bound of memory, but need upper bound. */           \
            if (result == JEEND) {                                             \
                /* the requested buffer size is beyond the extent of our       \
                 * allocation array */                                         \
                assert(NULL && "who needs this much memory?");                 \
                return currentBufSize * 1.2;                                   \
            }                                                                  \
            return *++result;                                                  \
        }                                                                      \
        if (*result >= currentBufSize) {                                       \
            /* found upper limit, ok. */                                       \
            return *result;                                                    \
        }                                                                      \
        assert(NULL && "unexpected combination of conditions");                \
        __builtin_unreachable();                                               \
    } while (0)

/* Tables from 1 MiB and up generated by the following script.
 * Compare against "Table 1. Size classes" at
 * http://www.canonware.com/download/jemalloc/jemalloc-latest/doc/jemalloc.html
 */
#if 0
currentVal = 4
step = 1

while currentVal < 1024 * 1024 * 1024:
    print "/* Step size: {} MiB */".format(step)
    for size in xrange(0, 4):
        currentVal = currentVal + step
        print "{} MiB, ".format(currentVal)
    step = step * 2
#endif

static size_t jebufSizeAllocation16(const size_t currentBufSize) {
    static const uint16_t jebuf[] = {
        8,      16,     32,     48,     64,     80,     96,     112,    128,
        160,    192,    224,    256,    320,    384,    448,    512,    640,
        768,    896,    1024,   1280,   1536,   1792,   2048,   2560,   3072,
        3584,   4096,   5 KiB,  6 KiB,  7 KiB,  8 KiB,  10 KiB, 12 KiB, 14 KiB,
        16 KiB, 20 KiB, 24 KiB, 28 KiB, 32 KiB, 40 KiB, 48 KiB, 54 KiB,
    };

    static const size_t num = COUNT(jebuf);

    const uint16_t *result = jebuf;
    size_t n = num;
    size_t half = n / 2;
    const uint16_t *mid = NULL;

    BINARY_SEARCH_BRANCH_FREE;

    RETURN_MOSTLY_SAFE_RESULT;
}

static size_t jebufSizeAllocation32(const size_t currentBufSize) {
    static const uint32_t jebuf[] = {
        64 KiB,
        80 KiB,
        96 KiB,
        112 KiB,
        128 KiB,
        160 KiB,
        192 KiB,
        224 KiB,
        256 KiB,
        320 KiB,
        384 KiB,
        448 KiB,
        512 KiB,
        640 KiB,
        768 KiB,
        896 KiB,
        1 MiB,
        1280 KiB,
        1536 KiB,
        1792 KiB,
        2 MiB,
        2560 KiB,
        3 MiB,
        3584 KiB,
        4 MiB,
        /* Step size: 1 MiB */
        5 MiB,
        6 MiB,
        7 MiB,
        8 MiB,
        /* Step size: 2 MiB */
        10 MiB,
        12 MiB,
        14 MiB,
        16 MiB,
        /* Step size: 4 MiB */
        20 MiB,
        24 MiB,
        28 MiB,
        32 MiB,
        /* Step size: 8 MiB */
        40 MiB,
        48 MiB,
        56 MiB,
        64 MiB,
        /* Step size: 16 MiB */
        80 MiB,
        96 MiB,
        112 MiB,
        128 MiB,
        /* Step size: 32 MiB */
        160 MiB,
        192 MiB,
        224 MiB,
        256 MiB,
        /* Step size: 64 MiB */
        320 MiB,
        384 MiB,
        448 MiB,
        512 MiB,
        /* Step size: 128 MiB */
        640 MiB,
        768 MiB,
        896 MiB,
        1024 MiB,
        /* Step size: 256 MiB */
        1280 MiB,
        1536 MiB,
        1792 MiB,
        2048 MiB,
        /* Step size: 512 MiB */
        2560 MiB,
        3072 MiB,
        3584 MiB,
    };

    static const size_t num = COUNT(jebuf);

    const uint32_t *result = jebuf;
    size_t n = num;
    size_t half = n / 2;
    const uint32_t *mid = NULL;

    BINARY_SEARCH_BRANCH_FREE;

    RETURN_MOSTLY_SAFE_RESULT;
}

static size_t jebufSizeAllocation64(const size_t currentBufSize) {
    static const uint64_t jebuf[] = {
        4096 MiB,
        /* Step size: 1024 MiB */
        5120 MiB,
        6144 MiB,
        7168 MiB,
        8192 MiB,
        /* Step size: 2048 MiB */
        10240 MiB,
        12288 MiB,
        14336 MiB,
        16384 MiB,
        /* Step size: 4096 MiB */
        20480 MiB,
        24576 MiB,
        28672 MiB,
        32768 MiB,
        /* Step size: 8192 MiB */
        40960 MiB,
        49152 MiB,
        57344 MiB,
        65536 MiB,
        /* Step size: 16384 MiB */
        81920 MiB,
        98304 MiB,
        114688 MiB,
        131072 MiB,
        /* Step size: 32768 MiB */
        163840 MiB,
        196608 MiB,
        229376 MiB,
        262144 MiB,
        /* Step size: 65536 MiB */
        327680 MiB,
        393216 MiB,
        458752 MiB,
        524288 MiB,
        /* Step size: 131072 MiB */
        655360 MiB,
        786432 MiB,
        917504 MiB,
        1048576 MiB,
        /* Step size: 262144 MiB */
        1310720 MiB,
        1572864 MiB,
        1835008 MiB,
        2097152 MiB,
        /* Step size: 524288 MiB */
        2621440 MiB,
        3145728 MiB,
        3670016 MiB,
        4194304 MiB,
        /* Step size: 1048576 MiB */ /* <-- 1 TB steps! */
        5242880 MiB,
        6291456 MiB,
        7340032 MiB,
        8388608 MiB,
        /* Step size: 2097152 MiB */ /* <-- 2 TB steps! */
        10485760 MiB,
        12582912 MiB,
        14680064 MiB,
        16777216 MiB,
        /* 16 TB should be enough for now.
         * any larger requests will assert failure. */
    };

    static const size_t num = COUNT(jebuf);

    const uint64_t *result = jebuf;
    size_t n = num;
    size_t half = n / 2;
    const uint64_t *mid = NULL;

    BINARY_SEARCH_BRANCH_FREE;

    RETURN_MOSTLY_SAFE_RESULT;
}

#ifdef DATAKIT_TEST

#include "ctest.h"

#define DOUBLE_NEWLINE 0
#include "perf.h"

#include <inttypes.h> /* PRIu64 */

#define REPORT_TIME 1
#if REPORT_TIME
#define TIME_INIT PERF_TIMERS_SETUP
#define TIME_FINISH(i, what) PERF_TIMERS_FINISH_PRINT_RESULTS(i, what)
#else
#define TIME_INIT
#define TIME_FINISH(i, what)
#endif

int jebufTest(int argc, char *argv[]) {
    (void)argc;
    (void)argv;

    int err = 0;

    const size_t loopers = 70000000;

    TEST("verify rounds up") {
        size_t next = jebufSizeAllocation(139583862445);
        if (next != 163840 MiB) {
            ERR("Expected 163840, but got %zu\n", next);
        }

        next = jebufSizeAllocation(0);
        if (next != 8) {
            ERR("Expected 8, but got %zu\n", next);
        }

        next = jebufSizeAllocation(53 KiB);
        if (next != 54 KiB) {
            ERR("Expected 54, but got %zu\n", next);
        }

        next = jebufSizeAllocation(54 KiB);
        if (next != 54 KiB) {
            ERR("Expected 54, but got %zu\n", next);
        }

        next = jebufSizeAllocation(3500 MiB);
        if (next != 3584 MiB) {
            ERR("Expected 3584, but got %zu\n", next);
        }

        next = jebufSizeAllocation(20000 MiB);
        if (next != 20480 MiB) {
            ERR("Expected 20480, but got %zu\n", next);
        }

        next = jebufSizeAllocation(261000 MiB);
        if (next != 262144 MiB) {
            ERR("Expected 262144, but got %zu\n", next);
        }

        next = jebufSizeAllocation(1048576 MiB);
        if (next != 1048576 MiB) {
            ERR("Expected 1048576, but got %zu\n", next);
        }
    }

    TEST("performance SizeClass") {
        {
            TIME_INIT;
            for (size_t i = 0; i < loopers; i++) {
                size_t next = jebufSizeAllocation(0);
                assert(next);
                (void)next;
            }
            TIME_FINISH(loopers, "perf SizeClass - 0");
        }

        {
            TIME_INIT;
            for (size_t i = 0; i < loopers; i++) {
                size_t next = jebufSizeAllocation(5000);
                assert(next);
                (void)next;
            }
            TIME_FINISH(loopers, "perf SizeClass - 5000");
        }

        {
            TIME_INIT;
            for (size_t i = 0; i < loopers; i++) {
                size_t next = jebufSizeAllocation(30000);
                assert(next);
                (void)next;
            }
            TIME_FINISH(loopers, "perf SizeClass - 30000");
        }

        {
            TIME_INIT;
            for (size_t i = 0; i < loopers; i++) {
                size_t next = jebufSizeAllocation(16777216);
                assert(next);
                (void)next;
            }
            TIME_FINISH(loopers, "perf SizeClass - 16777216");
        }

        {
            TIME_INIT;
            for (size_t i = 0; i < loopers; i++) {
                size_t next = jebufSizeAllocation(139583862445);
                assert(next);
                (void)next;
            }
            TIME_FINISH(loopers, "perf SizeClass - 139583862445");
        }
    }

    TEST_FINAL_RESULT;
}
#endif
